


负责checkpoint的关键类CheckpointCoordinator
在JobManager构建ExecutionGraph的过程中就会被创建
同时被创建的还有实现了JobStatusListener接口的CheckpointCoordinatorDeActivator(如果开启checkpoint)
JobManager调整任务状态从CREATED到RRUNNING后, Activator会触发CheckpointCoordinator的startCheckpointScheduler()方法

CheckpointCoordinator会部署ScheduledTrigger在后台周期性的根据用户设置的最大checkpoint并行数和interval判断是否需要新一轮的checkpoint
触发新一轮checkpoint, 首先创建PendingCheckpoint, 包含checkpointID和timestamp
然后远程调用TaskManager的triggerCheckpoint()方法

上述triggerCheckpoint()方法会先获取所有SourceStreamTask, 调用Task的triggerCheckpointBarrier()方法
该方法在后台异步的执行StreamTask的performCheckpoint()方法:
1、向下游广播CheckpointBarrier, 2、进行Source的snapshot

下游的task调用StreamTask中, CheckpointBarrierHandler的getNextNonBlocked()方法
根据CheckpointingMode不同, CheckpointBarrierHandler会返回不同的Handler:BarrierBuffer和BarrierTracker
如果是EXACTLY_ONCE, 就是BarrierBuffer, 会等待其他Barrier, 进行对齐, 缓存提前到来的数据
如果是AT_LEAST_ONCE, 就是BarrierTracker, 不会进行Barrier对齐, 继续处理数据,进而会处理checkpoint(n+1)的数据

Task执行完Checkpoint后会向JobMnager上报checkpoint的元数据信息
JobManager端的CheckpointCoordinator通过调用PendingCheckpoint的acknowledgeTask()方法,缓存到PendingCheckpoint

JobMnager的CheckpointCoordinator收到所有Sink Task的ack消息后, 就执行completePendingCheckpoint()
将checkpoint的数据存储到状态后端, 然后通知所有Task进行commit操作
这里主要涉及了二阶段提交, 当收到checkpoint后, 停止本轮事务但不commit, 确认记录到checkpoint后, 再commit

所有Task执行完commit, 调用notifyCheckpointComplete()方法回馈JobMnager, 一轮checkpoint结束


